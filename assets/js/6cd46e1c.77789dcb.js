(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{116:function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return m}));var r=t(0),o=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=o.a.createContext({}),u=function(e){var n=o.a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=u(e.components);return o.a.createElement(i.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},d=o.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,i=p(e,["components","mdxType","originalType","parentName"]),l=u(t),d=r,m=l["".concat(s,".").concat(d)]||l[d]||b[d]||a;return t?o.a.createElement(m,c(c({ref:n},i),{},{components:t})):o.a.createElement(m,c({ref:n},i))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=d;var c={};for(var p in n)hasOwnProperty.call(n,p)&&(c[p]=n[p]);c.originalType=e,c.mdxType="string"==typeof e?e:r,s[1]=c;for(var i=2;i<a;i++)s[i]=t[i];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},88:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return p})),t.d(n,"default",(function(){return u}));var r=t(3),o=t(7),a=(t(0),t(116)),s={id:"classes-limitations",title:"Limitations",sidebar_label:"Limitations"},c={unversionedId:"plugins-system/classes-limitations",id:"plugins-system/classes-limitations",isDocsHomePage:!1,title:"Limitations",description:"Circular Dependencies",source:"@site/docs/plugins-system/classes-limitations.md",slug:"/plugins-system/classes-limitations",permalink:"/docs/plugins-system/classes-limitations",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/plugins-system/classes-limitations.md",version:"current",sidebar_label:"Limitations",sidebar:"docs",previous:{title:"Metadata",permalink:"/docs/plugins-system/classes-metadata"},next:{title:"Transformer Plugin",permalink:"/docs/plugins-system/classes-transformer-plugin"}},p=[{value:"Circular Dependencies",id:"circular-dependencies",children:[{value:"Problem",id:"problem",children:[]},{value:"TypeOrm Example",id:"typeorm-example",children:[]},{value:"Solution",id:"solution",children:[]}]},{value:"Strict Mode",id:"strict-mode",children:[]}],i={toc:p};function u(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"circular-dependencies"},"Circular Dependencies"),Object(a.b)("h3",{id:"problem"},"Problem"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Circular Dependency")," occurs when you have two models that depend on each other. For example, ",Object(a.b)("inlineCode",{parentName:"p"},"SourceA")," depends on ",Object(a.b)("inlineCode",{parentName:"p"},"SourceB")," and ",Object(a.b)("inlineCode",{parentName:"p"},"SourceB")," also depends on ",Object(a.b)("inlineCode",{parentName:"p"},"SourceA"),".\nWhen designing your data models, both Domain and DTO (or View Model), you will probably run into circular dependency."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA })\n  sourceA: SourceA;\n}\n")),Object(a.b)("h3",{id:"typeorm-example"},"TypeOrm Example"),Object(a.b)("p",null,"This is very common when you set up your Entities using ",Object(a.b)("inlineCode",{parentName:"p"},"TypeOrm"),". Suppose you have two Entities: Order and Person"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Order {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @ManyToOne(() => Person, (person) => person.orders)\n  @AutoMap({ typeFn: () => Person })\n  person: Person;\n}\n\n@Entity()\nexport class Person {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @OneToMany(() => Order, (order) => order.person)\n  @AutoMap({ typeFn: () => Order })\n  orders: Order[];\n}\n")),Object(a.b)("p",null,"Here, you have introduced a ",Object(a.b)("strong",{parentName:"p"},"Circular Dependency")," with Order and Person."),Object(a.b)("h3",{id:"solution"},"Solution"),Object(a.b)("p",null,"In general, you should avoid introducing ",Object(a.b)("strong",{parentName:"p"},"Circular Dependency")," as much as possible. However, there are cases that you must have ",Object(a.b)("strong",{parentName:"p"},"Circular Dependency"),". For those cases, ",Object(a.b)("inlineCode",{parentName:"p"},"@automapper/classes")," has a concept of ",Object(a.b)("strong",{parentName:"p"},"depth")," of nesting models."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA })\n  sourceA: SourceA;\n}\n")),Object(a.b)("p",null,"Let's assume the above models, this is how ",Object(a.b)("strong",{parentName:"p"},"depth")," works:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Depth of 0")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"SourceA {\n    sourceB: SourceB {\n        sourceA: null\n    }\n}\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Depth of 1")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"SourceA {\n    sourceB: SourceB {\n        sourceA: SourceA {\n            sourceB: null;\n        }\n    }\n}\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Depth of 2")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"SourceA {\n    sourceB: SourceB {\n        sourceA: SourceA {\n            sourceB: {\n                sourceA: SourceA {\n                    sourceB: null;\n                }\n            }\n        }\n    }\n}\n")),Object(a.b)("p",null,"By default, ",Object(a.b)("inlineCode",{parentName:"p"},"@automapper/classes")," will apply ",Object(a.b)("strong",{parentName:"p"},"depth of 0")," to nested models. To specify ",Object(a.b)("strong",{parentName:"p"},"depth"),", use ",Object(a.b)("inlineCode",{parentName:"p"},"@AutoMap()")," decorator second argument:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"class SourceA {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceB, depth: 1 })\n  sourceB: SourceB;\n}\n\nclass SourceB {\n  @AutoMap()\n  id: number;\n  @AutoMap({ typeFn: () => SourceA, depth: 1 })\n  sourceA: SourceA;\n}\n")),Object(a.b)("p",null,"Please be advised that the bigger the ",Object(a.b)("strong",{parentName:"p"},"depth")," is, the bigger your model is, so you need to be very cautious when you start introducing ",Object(a.b)("strong",{parentName:"p"},"Circular Dependency"),"."),Object(a.b)("p",null,"Another possible solution is to ",Object(a.b)("strong",{parentName:"p"},"NOT")," decorate the circular-dependent member with ",Object(a.b)("inlineCode",{parentName:"p"},"@AutoMap()")," and configure the mapping for this member manually with ",Object(a.b)("inlineCode",{parentName:"p"},"mapWith()")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Order {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @ManyToOne(() => Person, (person) => person.orders)\n  person: Person;\n}\n\n@Entity()\nexport class Person {\n  @AutoMap()\n  id: number;\n  // ... shorten for brevity purpose\n  @OneToMany(() => Order, (order) => order.person)\n  orders: Order[];\n}\n\nmapper.createMap(SomeOrderDto, Order).forMember(\n  (d) => d.person,\n  mapWith(\n    () => Person,\n    (s) => s.person,\n    () => SomePersonDto\n  )\n);\nmapper.createMap(SomePersonDto, Person).forMember(\n  (d) => d.orders,\n  mapWith(\n    () => Order,\n    (s) => s.orders,\n    () => SomeOrderDto\n  )\n);\n")),Object(a.b)("h2",{id:"strict-mode"},"Strict Mode"),Object(a.b)("p",null,"If you have ",Object(a.b)("inlineCode",{parentName:"p"},"strict")," mode turned on, and you have ",Object(a.b)("strong",{parentName:"p"},"Union Type")," on your properties like: ",Object(a.b)("inlineCode",{parentName:"p"},"string | null"),", ",Object(a.b)("inlineCode",{parentName:"p"},"number | null"),", or ",Object(a.b)("inlineCode",{parentName:"p"},"boolean | null"),"; you need to pass the ",Object(a.b)("inlineCode",{parentName:"p"},"typeFn")," to ",Object(a.b)("inlineCode",{parentName:"p"},"@AutoMap()")," like the following:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-ts"},"export class User {\n  @AutoMap({ typeFn: () => String })\n  name!: string | null;\n  @AutoMap({ typeFn: () => Number })\n  age!: number | null;\n  @AutoMap({ typeFn: () => Boolean })\n  isAdmin!: boolean | null;\n}\n")),Object(a.b)("p",null,"This is due to ",Object(a.b)("strong",{parentName:"p"},"Weak Reflection")," when ",Object(a.b)("inlineCode",{parentName:"p"},"strict")," mode is enabled."))}u.isMDXComponent=!0}}]);