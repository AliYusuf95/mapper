(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{116:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return u}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function b(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),c=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},m=function(e){var t=c(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},s=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=b(e,["components","mdxType","originalType","parentName"]),m=c(n),s=a,u=m["".concat(o,".").concat(s)]||m[s]||d[s]||i;return n?r.a.createElement(u,p(p({ref:t},l),{},{components:n})):r.a.createElement(u,p({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=s;var p={};for(var b in t)hasOwnProperty.call(t,b)&&(p[b]=t[b]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var l=2;l<i;l++)o[l]=n[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},86:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return p})),n.d(t,"toc",(function(){return b})),n.d(t,"default",(function(){return c}));var a=n(3),r=n(7),i=(n(0),n(116)),o={id:"fundamentals",title:"Fundamentals",sidebar_label:"Fundamentals"},p={unversionedId:"fundamentals",id:"fundamentals",isDocsHomePage:!1,title:"Fundamentals",description:"We have looked at the Basic example but in order to get into some more details of AutoMapper, we need to be aware of some of the definitions used in @automapper/*",source:"@site/docs/fundamentals.md",slug:"/fundamentals",permalink:"/docs/fundamentals",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/fundamentals.md",version:"current",sidebar_label:"Fundamentals",sidebar:"docs",previous:{title:"Introduce to Profile",permalink:"/docs/getting-started/introduce-to-profile"},next:{title:"Auto in AutoMapper",permalink:"/docs/mapping-configuration/auto"}},b=[{value:"Mapper",id:"mapper",children:[]},{value:"Mapping",id:"mapping",children:[]},{value:"MappingProperty",id:"mappingproperty",children:[]},{value:"MappingTransformation",id:"mappingtransformation",children:[]},{value:"TransformationType",id:"transformationtype",children:[]},{value:"NamingConvention",id:"namingconvention",children:[]}],l={toc:b};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"We have looked at the ",Object(i.b)("a",{parentName:"p",href:"/docs/getting-started/introduce-to-automapper"},"Basic example")," but in order to get into some more details of AutoMapper, we need to be aware of some of the definitions used in ",Object(i.b)("inlineCode",{parentName:"p"},"@automapper/*")),Object(i.b)("h2",{id:"mapper"},"Mapper"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Mapper")," is the first-class citizen in ",Object(i.b)("inlineCode",{parentName:"p"},"@automapper/*"),". All ",Object(i.b)("a",{parentName:"p",href:"/docs/mapping-configuration/auto"},"Mapping Configuration")," and Map Operations are handled by ",Object(i.b)("inlineCode",{parentName:"p"},"Mapper"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Mapper")," is created by invoking ",Object(i.b)("inlineCode",{parentName:"p"},"createMapper()")," along with a ",Object(i.b)("a",{parentName:"p",href:"/docs/plugins-system/introduce-to-plugins"},"Plugin")),Object(i.b)("h2",{id:"mapping"},"Mapping"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," is a contract between a ",Object(i.b)("strong",{parentName:"p"},"Source")," model and a ",Object(i.b)("strong",{parentName:"p"},"Destination")," model. In our ",Object(i.b)("a",{parentName:"p",href:"/docs/getting-started/introduce-to-automapper"},"Basic example"),", our ",Object(i.b)("inlineCode",{parentName:"p"},"User")," is ",Object(i.b)("strong",{parentName:"p"},"Source")," while ",Object(i.b)("inlineCode",{parentName:"p"},"UserDto")," is ",Object(i.b)("strong",{parentName:"p"},"Destination"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," contains metadata as well as some configurations about the ",Object(i.b)("strong",{parentName:"p"},"Source")," and ",Object(i.b)("strong",{parentName:"p"},"Destination"),": models, naming conventions, map callbacks, ",Object(i.b)("a",{parentName:"p",href:"#mappingproperty"},"MappingProperty")," etc... We know what ",Object(i.b)("strong",{parentName:"p"},"models")," mean. We will explore the other definitions in other sections."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," is created by invoking ",Object(i.b)("inlineCode",{parentName:"p"},"mapper.createMap()"),". Within a ",Object(i.b)("inlineCode",{parentName:"p"},"Mapper"),", a ",Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," is ",Object(i.b)("strong",{parentName:"p"},"uni-directionally unique"),". In other words, we can have both ",Object(i.b)("inlineCode",{parentName:"p"},"Mapping<Source, Destination>")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Mapping<Destination, Source>"),"."),Object(i.b)("h2",{id:"mappingproperty"},"MappingProperty"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"MappingProperty")," is a record of information about a particular member on the ",Object(i.b)("strong",{parentName:"p"},"Destination")," along with its ",Object(i.b)("a",{parentName:"p",href:"#mappingtransformation"},"MappingTransformation"),"."),Object(i.b)("h2",{id:"mappingtransformation"},"MappingTransformation"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"MappingTransformation")," is an instruction of how a ",Object(i.b)("inlineCode",{parentName:"p"},"Mapper")," should map a particular member on the ",Object(i.b)("strong",{parentName:"p"},"Destination"),". ",Object(i.b)("inlineCode",{parentName:"p"},"MappingTransformation")," operates based on different types of ",Object(i.b)("a",{parentName:"p",href:"#transformationtype"},"TransformationType"),"."),Object(i.b)("h2",{id:"transformationtype"},"TransformationType"),Object(i.b)("p",null,"There are currently 9 ",Object(i.b)("inlineCode",{parentName:"p"},"TransformationType")," in ",Object(i.b)("inlineCode",{parentName:"p"},"@automapper/core"),"."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"@automapper/core")," exposes a collection of ",Object(i.b)("inlineCode",{parentName:"p"},"MemberMapFunction"),". Each function will return an appropriate ",Object(i.b)("inlineCode",{parentName:"p"},"TransformationType"),"."),Object(i.b)("p",null,"These functions are all separate and pure-functions which allows for ",Object(i.b)("strong",{parentName:"p"},"Tree-shaking"),"-enabled bundler to optimize the bundle-size of the consumers."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",{parentName:"tr",align:null},"Type"),Object(i.b)("th",{parentName:"tr",align:null},"MemberMapFunction"),Object(i.b)("th",{parentName:"tr",align:null},"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"Ignore"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"ignore()")),Object(i.b)("td",{parentName:"tr",align:null},"Ignore a member on the ",Object(i.b)("strong",{parentName:"td"},"Destination"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"MapFrom"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"mapFrom()")),Object(i.b)("td",{parentName:"tr",align:null},"Customized instruction for a member")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"Condition"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"condition()")),Object(i.b)("td",{parentName:"tr",align:null},"If the member on the ",Object(i.b)("strong",{parentName:"td"},"Destination")," matches with another member on the ",Object(i.b)("strong",{parentName:"td"},"Source"),", this will conditionally map the member on the ",Object(i.b)("strong",{parentName:"td"},"Source")," to ",Object(i.b)("strong",{parentName:"td"},"Destination")," if some predicate is evaluated to ",Object(i.b)("strong",{parentName:"td"},"truthy"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"FromValue"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"fromValue()")),Object(i.b)("td",{parentName:"tr",align:null},"Map a raw value to the member")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"MapWith"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"mapWith()")),Object(i.b)("td",{parentName:"tr",align:null},"In some cases where nested models do not work automatically, this is to specify the nested ",Object(i.b)("strong",{parentName:"td"},"Destination")," of the member as well as the nested ",Object(i.b)("strong",{parentName:"td"},"Source"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"ConvertUsing"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"convertUsing()")),Object(i.b)("td",{parentName:"tr",align:null},"Map a member using ",Object(i.b)("a",{parentName:"td",href:"/docs/mapping-configuration/convert-using"},"Converters"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NullSubstitution"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"nullSubstitution()")),Object(i.b)("td",{parentName:"tr",align:null},"If the member on ",Object(i.b)("strong",{parentName:"td"},"Source")," is ",Object(i.b)("inlineCode",{parentName:"td"},"null"),", this will substitute the ",Object(i.b)("inlineCode",{parentName:"td"},"null")," value with a different value for that member on ",Object(i.b)("strong",{parentName:"td"},"Destination"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"MapDefer"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"mapDefer()")),Object(i.b)("td",{parentName:"tr",align:null},"This can be used to ",Object(i.b)("em",{parentName:"td"},"defer")," a ",Object(i.b)("inlineCode",{parentName:"td"},"TransformationType")," with the ",Object(i.b)("strong",{parentName:"td"},"Source"),". For example, if ",Object(i.b)("strong",{parentName:"td"},"Source")," has data A, we want ",Object(i.b)("inlineCode",{parentName:"td"},"MapFrom")," but if ",Object(i.b)("strong",{parentName:"td"},"Source")," has B, we want to ",Object(i.b)("inlineCode",{parentName:"td"},"Ignore"))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"MapWithArguments"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("inlineCode",{parentName:"td"},"mapWithArguments()")),Object(i.b)("td",{parentName:"tr",align:null},"This can be used to ",Object(i.b)("em",{parentName:"td"},"map")," with extra arguments where the arguments come in at runtime when ",Object(i.b)("inlineCode",{parentName:"td"},"map()")," is invoked")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"MapInitialize"),Object(i.b)("td",{parentName:"tr",align:null},"internal ",Object(i.b)("inlineCode",{parentName:"td"},"mapInitialize()")),Object(i.b)("td",{parentName:"tr",align:null},"This is used ",Object(i.b)("strong",{parentName:"td"},"internally")," to initialize the ",Object(i.b)("inlineCode",{parentName:"td"},"MappingProperty")," with the ",Object(i.b)("strong",{parentName:"td"},"Destination")," metadata")))),Object(i.b)("h2",{id:"namingconvention"},"NamingConvention"),Object(i.b)("p",null,"As the name suggests, ",Object(i.b)("inlineCode",{parentName:"p"},"NamingConvention")," allows for ",Object(i.b)("inlineCode",{parentName:"p"},"Mapper")," to map models with different casing. ",Object(i.b)("inlineCode",{parentName:"p"},"@automapper/core")," provides 3 conventions:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CamelCaseNamingConvention")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"PascalCaseNamingConvention")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"SnakeCaseNamingConvention"))),Object(i.b)("p",null,"By default, ",Object(i.b)("inlineCode",{parentName:"p"},"@automapper/*")," does not set a default convention. ",Object(i.b)("a",{parentName:"p",href:"/docs/mapping-configuration/auto#flattening"},"Flattening")," can only be applied when ",Object(i.b)("inlineCode",{parentName:"p"},"NamingConvention")," is set on the models, even if they have the same casing."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"NamingConvention")," can be applied to a ",Object(i.b)("strong",{parentName:"p"},"unique")," ",Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," with ",Object(i.b)("inlineCode",{parentName:"p"},"mapper.createMap()"),", or can be applied globally to all ",Object(i.b)("inlineCode",{parentName:"p"},"Mapping")," within a single ",Object(i.b)("inlineCode",{parentName:"p"},"Mapper")," with ",Object(i.b)("inlineCode",{parentName:"p"},"createMapper()"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"const mapper = createMapper({\n  name,\n  pluginInitializer,\n  namingConventions: new CamelCaseNamingConvention(), // global\n});\n\n// or\n\nmapper.createMap(User, UserDto, {\n  namingConventions: new CamelCaseNamingConvention(),\n});\n")))}c.isMDXComponent=!0}}]);