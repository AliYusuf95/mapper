(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{108:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return l}));var a=t(3),r=t(7),p=(t(0),t(116)),o={id:"migrations",title:"Migrations",sidebar_label:"Migrations"},i={unversionedId:"migrations",id:"migrations",isDocsHomePage:!1,title:"Migrations",description:"Library Scope",source:"@site/docs/migrations.md",slug:"/migrations",permalink:"/docs/migrations",editUrl:"https://github.com/nartc/mapper/tree/main/docs-site/docs/migrations.md",version:"current",sidebar_label:"Migrations",sidebar:"docs",previous:{title:"NestJS Integration",permalink:"/docs/nestjs"}},s=[{value:"Library Scope",id:"library-scope",children:[]},{value:"Versioning",id:"versioning",children:[]},{value:"Migrate from <code>@nartc/automapper</code>",id:"migrate-from-nartcautomapper",children:[{value:"Install <code>@automapper/*</code>",id:"install-automapper",children:[]},{value:"Create a <code>Mapper</code> with <code>@automapper/classes</code>",id:"create-a-mapper-with-automapperclasses",children:[]},{value:"Default settings",id:"default-settings",children:[]},{value:"<code>Profile</code>",id:"profile",children:[]},{value:"<code>Converter</code>",id:"converter",children:[]},{value:"<code>Resolver</code>",id:"resolver",children:[]},{value:"Inheritance",id:"inheritance",children:[]},{value:"<code>MapAction</code> (aka callbacks)",id:"mapaction-aka-callbacks",children:[]},{value:"Empty Values",id:"empty-values",children:[]},{value:"Reverse Mapping",id:"reverse-mapping",children:[]},{value:"<code>map()</code> variations API changes",id:"map-variations-api-changes",children:[]},{value:"<code>skipUnmappedAssertion</code> is removed",id:"skipunmappedassertion-is-removed",children:[]},{value:"<code>enum</code> properties",id:"enum-properties",children:[]}]},{value:"Migrate from <code>nestjsx-automapper</code>",id:"migrate-from-nestjsx-automapper",children:[{value:"Install <code>@automapper/nestjs</code> and <code>peerDependencies</code>",id:"install-automappernestjs-and-peerdependencies",children:[]},{value:"Initialization",id:"initialization",children:[]},{value:"<code>MappingProfile</code>",id:"mappingprofile",children:[]}]}],c={toc:s};function l(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(p.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(p.b)("h2",{id:"library-scope"},"Library Scope"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," and ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/*")," are essentially two different packages. Technically, ",Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," is the base for ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," and ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/classes"),"."),Object(p.b)("p",null,"In the near future, ",Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," will be archived (v7 would still be available) and will not receive any bug fixes or new features. All the effort will be spent toward ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/*"),"."),Object(p.b)("h2",{id:"versioning"},"Versioning"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," is currently at v7. ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/*")," will start out with v1.0.0 and will strictly follow ",Object(p.b)("a",{parentName:"p",href:"https://semver.org/"},"Semantic Versioning"),"."),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@automapper/*")," is a collection of packages that would all follow the same version number at any given time."),Object(p.b)("h2",{id:"migrate-from-nartcautomapper"},"Migrate from ",Object(p.b)("inlineCode",{parentName:"h2"},"@nartc/automapper")),Object(p.b)("h3",{id:"install-automapper"},"Install ",Object(p.b)("inlineCode",{parentName:"h3"},"@automapper/*")),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-bash"},"npm i @automapper/{core,classes}\nnpm i -D @automapper/types\n# or with yarn\nyarn add @automapper/{core,classes}\nyarn add -D @automapper/types\n")),Object(p.b)("h3",{id:"create-a-mapper-with-automapperclasses"},"Create a ",Object(p.b)("inlineCode",{parentName:"h3"},"Mapper")," with ",Object(p.b)("inlineCode",{parentName:"h3"},"@automapper/classes")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," does not expose a ",Object(p.b)("inlineCode",{parentName:"p"},"Mapper")," constant anymore because ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," operates based on a ",Object(p.b)("inlineCode",{parentName:"p"},"MapPlugin")," you pick, and you can have multiple ",Object(p.b)("inlineCode",{parentName:"p"},"Mapper")," for each plugin."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Mapper } from '@nartc/automapper';\n\nMapper.createMap(...);\n\n// after\nimport { createMapper } from '@automapper/core';\nimport { classes } from '@automapper/classes';\n\nconst mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes\n})\n\nmapper.createMap(...);\n")),Object(p.b)("h3",{id:"default-settings"},"Default settings"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," sets some default settings which are ",Object(p.b)("inlineCode",{parentName:"p"},"NamingConvention")," and ",Object(p.b)("inlineCode",{parentName:"p"},"ErrorHandler"),". ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," does not set any default ",Object(p.b)("inlineCode",{parentName:"p"},"NamingConvention")," and it sets ",Object(p.b)("inlineCode",{parentName:"p"},"console.error")," for ",Object(p.b)("inlineCode",{parentName:"p"},"ErrorHandler#handle"),"."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"const mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes,\n  namingConventions: new CamelCaseNamingConvention(),\n});\n")),Object(p.b)("p",null,"For ",Object(p.b)("inlineCode",{parentName:"p"},"ErrorHandler"),", it is now an interface with a ",Object(p.b)("inlineCode",{parentName:"p"},"handle")," method so you can just provide that as well"),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"const mapper = createMapper({\n  name: 'arbitrary name',\n  pluginInitializer: classes,\n  namingConventions: new CamelCaseNamingConvention(),\n  errorHandler: {\n    handle: (error) => {\n      // custom error handler\n    },\n  },\n});\n")),Object(p.b)("h3",{id:"profile"},Object(p.b)("inlineCode",{parentName:"h3"},"Profile")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Profile")," in ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," is just a function that accepts the ",Object(p.b)("inlineCode",{parentName:"p"},"Mapper")," object and returns nothing (",Object(p.b)("inlineCode",{parentName:"p"},"void"),")."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { ProfileBase } from '@nartc/automapper';\n\nexport class UserProfile extends ProfileBase {\n  constructor(mapper: AutoMapper) {\n    super()\n    mapper.createMap(...)\n  }\n}\n\n// after\nimport type { MappingProfile } from '@automapper/types';\n\nexport const userProfile: MappingProfile = mapper => {\n  mapper.createMap(...)\n}\n")),Object(p.b)("h3",{id:"converter"},Object(p.b)("inlineCode",{parentName:"h3"},"Converter")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Converter")," in ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," is just an object with the ",Object(p.b)("inlineCode",{parentName:"p"},"convert")," method that accepts a ",Object(p.b)("inlineCode",{parentName:"p"},"sourceData")," and returns a ",Object(p.b)("inlineCode",{parentName:"p"},"destinationData"),"."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Converter } from '@nartc/automapper';\n\nexport class DateStringConverter implements Converter<Date, string> {\n  convert(source: Date): string {\n    return source.toDateString();\n  }\n}\n\n// after\nimport type { Converter } from '@automapper/types';\n\nexport const dateStringConverter: Converter<Date, string> = {\n  convert(source) {\n    return source.toDateString();\n  },\n};\n")),Object(p.b)("h3",{id:"resolver"},Object(p.b)("inlineCode",{parentName:"h3"},"Resolver")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"Resolver")," in ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," is just an object with the ",Object(p.b)("inlineCode",{parentName:"p"},"resolve")," method that accepts a ",Object(p.b)("inlineCode",{parentName:"p"},"(source, destination?)")," and returns data that matches with ",Object(p.b)("inlineCode",{parentName:"p"},"destination#member")," type."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Resolver } from '@nartc/automapper';\n\nexport class TaxResolver implements Resolver<Item, ItemDto, number> {\n  resolve(source: Item): number {\n    return source.type === 'A' ? source.price * 0.5 : source.price * 0.9;\n  }\n}\n\n// after\nimport type { Resolver } from '@automapper/types';\n\nexport const taxResolver: Resolver<Item, ItemDto, number> = {\n  resolve(source) {\n    return source.type === 'A' ? source.price * 0.5 : source.price * 0.9;\n  },\n};\n")),Object(p.b)("h3",{id:"inheritance"},"Inheritance"),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"class Base {...}\nclass BaseDto {...}\n\nclass User extends Base {...}\nclass UserDto extends BaseDto {...}\n\n// before\nimport { Mapper } from '@nartc/automapper';\n\nMapper.createMap(Base, BaseDto);\nMapper.createMap(User, UserDto, { includeBase: [Base, BaseDto] });\n\n// after\nimport { mapper } from 'your/path/to/your-mapper'\n\nmapper.createMap(Base, BaseDto);\nmapper.createMap(User, UserDto, { extends: [mapper.getMapping(Base, BaseDto)] })\n")),Object(p.b)("p",null,"This approach allows you to have ",Object(p.b)("inlineCode",{parentName:"p"},"Mapping<User, UserDto>")," extends as many mappings as possible. There's a downside that is the typings for ",Object(p.b)("inlineCode",{parentName:"p"},"extends")," is a little loose."),Object(p.b)("h3",{id:"mapaction-aka-callbacks"},Object(p.b)("inlineCode",{parentName:"h3"},"MapAction")," (aka callbacks)"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"beforeMap")," and ",Object(p.b)("inlineCode",{parentName:"p"},"afterMap")," work the same as before. However, they will be invoked with ",Object(p.b)("inlineCode",{parentName:"p"},"(source, destination)")," instead of ",Object(p.b)("inlineCode",{parentName:"p"},"(source, destination, mapping)")),Object(p.b)("h3",{id:"empty-values"},"Empty Values"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," dictates ",Object(p.b)("inlineCode",{parentName:"p"},"undefined")," or ",Object(p.b)("inlineCode",{parentName:"p"},"null")," to assign to empty values. ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," will not do this. All empty values will be ",Object(p.b)("inlineCode",{parentName:"p"},"undefined"),". ",Object(p.b)("inlineCode",{parentName:"p"},"null")," will still be mapped to ",Object(p.b)("inlineCode",{parentName:"p"},"null"),"."),Object(p.b)("h3",{id:"reverse-mapping"},"Reverse Mapping"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"reverseMap()")," has been removed in ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/*"),". The reason is Reverse Mapping is very tricky to get right, and it requires a lot of code to make it work, and it is not even working correctly."),Object(p.b)("p",null,"If you need ",Object(p.b)("inlineCode",{parentName:"p"},"reverseMap()"),", just call ",Object(p.b)("inlineCode",{parentName:"p"},"createMap()")," with the models again."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nMapper.createMap(User, UserDto).reverseMap();\n\n// after\nmapper.createMap(User, UserDto);\nmapper.createMap(UserDto, User);\n")),Object(p.b)("h3",{id:"map-variations-api-changes"},Object(p.b)("inlineCode",{parentName:"h3"},"map()")," variations API changes"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," works only with Class so the ",Object(p.b)("inlineCode",{parentName:"p"},"map()")," method in ",Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," makes passing in the ",Object(p.b)("inlineCode",{parentName:"p"},"source")," type optional and will try to guess the type of ",Object(p.b)("inlineCode",{parentName:"p"},"source")," with: ",Object(p.b)("inlineCode",{parentName:"p"},"sourceObj.constructor"),"."),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core")," works with different type now so ",Object(p.b)("inlineCode",{parentName:"p"},"source")," type has been made mandatory."),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nMapper.map(sourceObj, Destination);\n\n// after\nmapper.map(sourceObj, Destination, Source);\n")),Object(p.b)("h3",{id:"skipunmappedassertion-is-removed"},Object(p.b)("inlineCode",{parentName:"h3"},"skipUnmappedAssertion")," is removed"),Object(p.b)("p",null,"In ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core"),", ",Object(p.b)("inlineCode",{parentName:"p"},"ErrorHandler#handle")," is default to ",Object(p.b)("inlineCode",{parentName:"p"},"console.error"),". ",Object(p.b)("inlineCode",{parentName:"p"},"skipUnmappedAssertion")," was added to ",Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," to prevent having a thrown exception leading to a crash. It is not needed with ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/core"),"."),Object(p.b)("blockquote",null,Object(p.b)("p",{parentName:"blockquote"},"Note: In the event of unmapped properties, the error is still be logged to the Console. If this is something you do not want, please ",Object(p.b)("a",{parentName:"p",href:"https://github.com/nartc/mapper/issues"},"open an Issue"))),Object(p.b)("h3",{id:"enum-properties"},Object(p.b)("inlineCode",{parentName:"h3"},"enum")," properties"),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"@AutoMap()")," on enum properties might behave differently based on the ",Object(p.b)("inlineCode",{parentName:"p"},"tsconfig")," that your application is using (either for serving or building). If you run into issues with Enum properties, provide additional information for ",Object(p.b)("inlineCode",{parentName:"p"},"@AutoMap()")),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// string enum\n@AutoMap({ typeFn: () => String })\nrole: UserRole\n\n// number enum\n@AutoMap({ typeFn: () => Number })\nrole: UserRole\n")),Object(p.b)("p",null,"This might not be the case for ",Object(p.b)("inlineCode",{parentName:"p"},"@nartc/automapper")," but the ",Object(p.b)("inlineCode",{parentName:"p"},"@AutoMap()")," decorator is reworked a little (to be lighter and more consistent) in ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/classes"),"."),Object(p.b)("h2",{id:"migrate-from-nestjsx-automapper"},"Migrate from ",Object(p.b)("inlineCode",{parentName:"h2"},"nestjsx-automapper")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"nestjsx-automapper")," will also be archived due to the release of ",Object(p.b)("inlineCode",{parentName:"p"},"@automapper/nestjs")," which is the official integration package with ",Object(p.b)("a",{parentName:"p",href:"https://nestjs.com"},"NestJS")),Object(p.b)("h3",{id:"install-automappernestjs-and-peerdependencies"},"Install ",Object(p.b)("inlineCode",{parentName:"h3"},"@automapper/nestjs")," and ",Object(p.b)("inlineCode",{parentName:"h3"},"peerDependencies")),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-bash"},"npm i @automapper/{core,classes,nestjs}\nnpm i -D @automapper/types\n# or with yarn\nyarn add @automapper/{core,classes,nestjs}\nyarn add -D @automapper/types\n")),Object(p.b)("h3",{id:"initialization"},"Initialization"),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { AutomapperModule } from 'nestjsx-automapper';\n\n@Module({\n  imports: [AutomapperModule.withMapper()],\n})\nexport class AppModule {}\n\n// after\nimport { AutomapperModule } from '@automapper/nestjs';\nimport { classes } from '@automapper/classes';\n\n@Module({\n  imports: [\n    AutomapperModule.forRoot({\n      options: [\n        // can initialize multiple mappers for each plugins\n        {\n          name: 'arbitrary name',\n          pluginInitializer: classes,\n          namingConventions: new CamelCaseNamingConvention(),\n        },\n      ],\n      singular: true, // default to false. set to true if you want to use `InjectMapper()` without passing in anything\n    }),\n  ],\n})\nexport class AppModule {}\n")),Object(p.b)("h3",{id:"mappingprofile"},Object(p.b)("inlineCode",{parentName:"h3"},"MappingProfile")),Object(p.b)("pre",null,Object(p.b)("code",{parentName:"pre",className:"language-ts"},"// before\nimport { Profile, ProfileBase, AutoMapper } from 'nestjsx-automapper';\n\n@Profile()\nexport class UserProfile extends ProfileBase {\n  constructor(mapper: AutoMapper) {\n    super();\n    mapper.createMap(...)\n  }\n}\n\n// in some other files that are guaranteed to load by webpack\nimport 'path/to/profile'\n\n\n// after\nimport { Injectable } from '@nestjs/common';\nimport { AutomapperProfile, InjectMapper } from '@automapper/nestjs';\nimport type { Mapper } from '@automapper/types';\n\n@Injectable()\nexport class UserProfile extends AutomapperProfile {\n  constructor(@InjectMapper() mapper: Mapper) { // can inject other services\n    super(mapper);\n  }\n\n  mapProfile() {\n    return mapper => {\n      mapper.createMap(...)\n    }\n  }\n}\n\n// in some module\n@Module({\n  imports: [...],\n  providers: [UserProfile]\n})\nexport class SomeModule {}\n")),Object(p.b)("p",null,Object(p.b)("inlineCode",{parentName:"p"},"mapProfile()")," will be called automatically by ",Object(p.b)("inlineCode",{parentName:"p"},"AutomapperProfile"),"."))}l.isMDXComponent=!0},116:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a);function p(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){p(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},p=Object.keys(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),l=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=l(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},d=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,p=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(t),d=a,u=m["".concat(o,".").concat(d)]||m[d]||b[d]||p;return t?r.a.createElement(u,i(i({ref:n},c),{},{components:t})):r.a.createElement(u,i({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var p=t.length,o=new Array(p);o[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<p;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);